Generators reference
====================
_This section is incomplete._

The following is a reference of all the included generators of RapidCheck. These generators are accessed by factory functions in the `rc::gen` namespace. The signatures should not be taken literally and only as a description of "what is meant", not the actual declaration in the source.

## Basic ##

### `Gen<T> arbitrary<T>()` ###
Generates an arbitrary value of type `T`. Support for new types can be added by specializing `struct rc::Arbitrary<T>` and providing a static method `arbitrary()` which returns an appropriate generator. For more information see the documentation on [generators](generators.md). The semantics of the returned generator depends entirely on the implementation of the `Arbitrary` specialization.

This generator is also used by RapidCheck whenever it implicitly needs a generator for some type, for example when generating arguments to properties.

```C++
// Example:
const auto str = *gen::arbitrary<std::vector<std::string>>();
```

### `Gen<std::tuple<Ts...>> tuple(Gen<Ts>... gens)` ###
Generates an `std::tuple` using the given generators to generate elements.

```C++
// Example:
const auto tuple = *gen::tuple(gen::arbitrary<std::string>(),
                               gen::arbitrary<int>(),
                               gen::arbitrary<float>());
```

### `Gen<std::pair<T1, T2>> pair(Gen<T1> gen1, Gen<T2> gen2)` ###
Similar to `tuple` but generates `std::pair` instead.

```C++
// Example:
const auto pair = *gen::pair(gen::arbitrary<std::string>(),
                             gen::arbitrary<int>());
```

### `Gen<T> construct<T>(Gen<Args>... gens)` ###
Generates objects of type `T` constructed using arguments from the given generators.

```C++
// Example:
const auto person = *gen::construct<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<std::unique_ptr<T>> makeUnique<T>(Gen<Args>... gens)` ###
Like `construct` but generates `std::unique_ptr`s to `T` instead.

```C++
// Example:
const auto person = *gen::makeUnique<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<std::shared_ptr<T>> makeShared<T>(Gen<Args>... gens)` ###
Like `construct` but generates `std::shared_ptr`s to `T` instead.

```C++
// Example:
const auto person = *gen::makeShared<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<T> build(Gen<T> gen, Bindings... bindings)` ###
Generates objects of type `T` by setting members of the object according to the specified bindings. A binding is created using `gen::set(Member member, Gen<T> gen)`. `Member` should be a pointer to a member of that object and `gen` should be an appropriate generator for the type of the member. The member may be one of:

- A member variable in which case `gen` should be a generator for the type of that variable.
- A member function that takes a single argument. `gen` should be a generator for the type of that argument.
- A member function that takes multiple arguments. `gen` should be a generator of tuples matching those arguments.

The generator may be omitted in which case `gen::arbitrary<T>()` will be used where `T` is the appropriate type of the generator.

The initial value is generated by the specified generator after which the bindings are applied.

```C++
// Example:
const auto person = *gen::build(gen::construct<Person>(genName()),
                                gen::set(&Person::age,
                                         gen::inRange(0, 100)),
                                gen::set(&Person::phoneNumber),
                                gen::set(&Person::setGender,
                                         gen::element("Male", "Female")),
                                gen::set(&Person::setAddress,
                                         gen::tuple(
                                             genCity(),
                                             genStreet(),
                                             genZipcode())));
```

### `Gen<T> build(Bindings... bindings)` ###
Like `build(Gen<T> gen, Bindings... bindings)` but `T` is default constructed. Since no generator is specified, `T` cannot be deduced and must be explicitly specified.

### `Gen<Container> container(Gen<Ts>... gens)` ###
Generates an STL container containing elements generated by the given generator(s). For most containers you should only specify one generator but for containers that have both keys and values (i.e. maps), you need to supply two separate generators. The type parameter must be sepcified explicitly.

```C++
// Example:
const auto smallInts = *gen::container<std::vector<int>>(gen::inRange(0, 100));
```

### `Gen<Container> container(std::size_t count, Gen<Ts>... gens)` ###
Like `container(Gen<Ts>... gens)` but generates containers of a fixed size `count.`

### `Gen<T> just(T value)` ###
Constantly generates `value`.

```C++
// Example:
const auto alwaysLeet = gen::just(1337);
```

### `Gen<T> lazy(Callable callable)` ###
Returns a generator which delegates generation to the generator lazily returned by `callable`. This is useful when creating generators for recursive data types such as trees. The type of the returned generator is the same as the type of the generator returned by `callable`.

```C++
// Example:
Gen<LinkedList> genLinkedList() {
  // NOTE: gen::lazy is required, otherwise, we'll go into infinite recursion
  //       that never terminates
  return gen::oneOf(gen::just(LinkedList()),
                    gen::construct<LinkedList>(gen::arbitrary<int>(),
                                               gen::lazy(&genLinkedlist)));
}
```

### `Gen<T> distinctFrom(Gen<T> gen, T value)` ###
Generates a value using `gen` that is not equal to `value`.

```C++
// Example:
const auto a = *gen::arbitrary<int>();
const auto b = *gen::distinctFrom(gen::inRange(0, 100), a);
```

### `Gen<T> distinctFrom(T value)` ###
Like `distinctFrom(Gen<T> gen, T value)` but uses `gen::arbitrary<T>()` as the generator.

### `Gen<T> exec(Callable callable)` ###
This allows you to use the same semantics that is used for properties when creating a generator. However, instead of `callable` yielding a success or a failure, it should return the generated value.

Inside the specified callable, you can use `operator*` of `Gen<T>` to pick values. In this way, you can have the values of one generator depend on the other. Just like with properties, if `callable` has any arguments, those will be generate with tuple-like semantics using `gen::arbitrary<T>()` for the appropriate types.

*Note:* If there are other combinators you can use instead of `gen::exec`, you are encouraged to do so. Because of its implementation, `gen::exec` is likely to have both worse compile time performance _and_ runtime performance than any options. In addition, if the picked values do not actually depend on each other, RapidCheck will be unnecessarily restricted in the way that it can shrink them on failure.

```C++
// Example:
const auto name = *gen::exec([](const Address &address) {
  const auto gender = *gen::element(kMale, kFemale);
  const auto name = *genName(gender);
  return Person(name, gender, address);
});
```

### `Gen<Maybe<T>> maybe(Gen<T> gen)` ###
Generates a `Maybe` of the type of the given generator. At small sizes, the frequency of `Nothing` is greater than at larger sizes.

```
// Example:
const auto maybeSmallInt = *gen::maybe(gen::inRange(0, 100));
```

### `Gen<T> inRange(T min, T max)` ###
Generates an integer between `min` (inclusive) and `max` (exclusive). The part of the range that is used grows with size and when size is `0`, only `min` is generated. When shrinking, the value will shrink towards `min`.

```C++
// Example:
const auto age = *gen::inRange<int>(0, 100);
```

### `Gen<T> nonZero()` ###
Generates a value that is not equal to `0`.

```C++
// Example:
const auto x = *gen::nonZero<int>();
```

### `Gen<T> positive()` ###
Generates a value which is greater than `0`.

```C++
// Example:
const auto x = *gen::positive<int>();
```

### `Gen<T> negative()` ###
Generates a value which is less than `0`.


```C++
// Example:
const auto x = *gen::positive<int>();
```

### `Gen<T> nonNegative()` ###
Generates a value which is not less than `0`.

```C++
// Example:
const auto x = *gen::positive<int>();
```

### `Gen<T> nonEmpty(Gen<T> gen)` ###
Generates a value `x` using the given generator for `x.empty()` is false. Useful with strings, STL containers and other similar types.

```C++
// Example:
const auto nonEmptyString = *gen::nonEmpty(gen::string());
```

### `Gen<T> nonEmpty()` ###
Same as `nonEmpty(Gen<T>)` but uses `gen::arbitrary<T>()`.

```C++
// Example:
const auto nonEmptyInts = *gen::nonEmpty<std::vector<int>>();
```
