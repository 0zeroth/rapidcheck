Generators reference
====================
_This section is incomplete._

The following is a reference of all the included generators of RapidCheck. These generators are accessed by factory functions in the `rc::gen` namespace. The signatures should not be taken literally and only as a description of "what is meant", not the actual declaration in the source.

## Basic ##

### `Gen<T> arbitrary<T>()` ###
Generates an arbitrary value of type `T`. Support for new types can be added by specializing `struct rc::Arbitrary<T>` and providing a static method `arbitrary()` which returns an appropriate generator. For more information see the documentation on [generators](generators.md). The semantics of the returned generator depends entirely on the implementation of the `Arbitrary` specialization.

This generator is also used by RapidCheck whenever it implicitly needs a generator for some type, for example when generating arguments to properties.

```C++
// Example:
const auto str = *gen::arbitrary<std::vector<std::string>>();
```

### `Gen<std::tuple<Ts...>> tuple(Gen<Ts>... gens)` ###
Generates an `std::tuple` using the given generators to generate elements.

```C++
// Example:
const auto tuple = *gen::tuple(gen::arbitrary<std::string>(),
                               gen::arbitrary<int>(),
                               gen::arbitrary<float>());
```

### `Gen<std::pair<T1, T2>> pair(Gen<T1> gen1, Gen<T2> gen2)` ###
Similar to `tuple` but generates `std::pair` instead.

```C++
// Example:
const auto pair = *gen::pair(gen::arbitrary<std::string>(),
                             gen::arbitrary<int>());
```

### `Gen<T> construct<T>(Gen<Args>... gens)` ###
Generates objects of type `T` constructed using arguments from the given generators.

```C++
// Example:
const auto person = *gen::construct<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<std::unique_ptr<T>> makeUnique<T>(Gen<Args>... gens)` ###
Like `construct` but generates `std::unique_ptr`s to `T` instead.

```C++
// Example:
const auto person = *gen::makeUnique<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<std::shared_ptr<T>> makeShared<T>(Gen<Args>... gens)` ###
Like `construct` but generates `std::shared_ptr`s to `T` instead.

```C++
// Example:
const auto person = *gen::makeShared<Person>(
    gen::arbitrary<std::string>(), // Name
    gen::arbitrary<std::string>(), // Hometown
    gen::inRange(0, 100));         // Age
```

### `Gen<T> build(Gen<T> gen, Bindings... bindings)` ###
Generates objects of type `T` by setting members of the object according to the specified bindings. A binding is created using `gen::set(Member member, Gen<T> gen)`. `Member` should be a pointer to a member of that object and `gen` should be an appropriate generator for the type of the member. The member may be one of:

- A member variable in which case `gen` should be a generator for the type of that variable.
- A member function that takes a single argument. `gen` should be a generator for the type of that argument.
- A member function that takes multiple arguments. `gen` should be a generator of tuples matching those arguments.

The generator may be omitted in which case `gen::arbitrary<T>()` will be used where `T` is the appropriate type of the generator.

The initial value is generated by the specified generator after which the bindings are applied.

```C++
// Example:
const auto person = *gen::build(gen::construct<Person>(genName()),
                                gen::set(&Person::age,
                                         gen::inRange(0, 100)),
                                gen::set(&Person::phoneNumber),
                                gen::set(&Person::setGender,
                                         gen::element("Male", "Female")),
                                gen::set(&Person::setAddress,
                                         gen::tuple(
                                             genCity(),
                                             genStreet(),
                                             genZipcode())));
```

### `Gen<T> build(Bindings... bindings)` ###
Like `build(Gen<T> gen, Bindings... bindings)` but `T` is default constructed. Since no generator is specified, `T` cannot be deduced and must be explicitly specified.

### `Gen<Container> container(Gen<Ts>... gens)` ###
Generates an STL container containing elements generated by the given generator(s). For most containers you should only specify one generator but for containers that have both keys and values (i.e. maps), you need to supply two separate generators. The type parameter must be sepcified explicitly.

```C++
// Example:
const auto smallInts = *gen::container<std::vector<int>>(gen::inRange(0, 100));
```

### `Gen<Container> container(std::size_t count, Gen<Ts>... gens)` ###
Like `container(Gen<Ts>... gens)` but generates containers of a fixed size `count.`

### `Gen<T> just(T value)` ###
Constantyly generates `value`.

```C++
// Example:
const auto alwaysLeet = gen::just(1337);
```

### `Gen<T> lazy(Callable callable)` ###
Returns a generator which delegates generation to the generator lazily returned by `callable`. This is useful when creating generators for recursive data types such as trees.

```C++
// Example:
Gen<LinkedList> genLinkedList() {
  // NOTE: gen::lazy is required, otherwise, we'll go into infinite recursion
  //       that never terminates
  return gen::oneOf(gen::just(LinkedList()),
                    gen::construct<LinkedList>(gen::arbitrary<int>(),
                                               gen::lazy(&genLinkedlist)));
}
```

### `Gen<T> distinctFrom(Gen<T> gen, T value)` ###
Generates a value using `gen` that is not equal to `value`.

```C++
// Example:
const auto a = *gen::arbitrary<int>();
const auto b = *gen::distinctFrom(gen::inRange(0, 100), a);
```

### `Gen<T> distinctFrom(T value)` ###
Like `distinctFrom(Gen<T> gen, T value)` but uses `gen::arbitrary<T>()` as the generator.
