Generators
==========
To generate input data for properties, RapidCheck uses the concept of generators. A generator which generates values of type `T` has the type [`Gen<T>`](Gen.md).

RapidCheck includes functions for creating generators for most common types and use cases but it also provides combinators that allow you to build custom generators by combining existing ones. These are generally located in the `rc::gen` namespace. In for some reason you cannot use the built in generators and combinators, you can also implement a generator from scratch. See [the documentation for `Gen`](Gen.md) for more information about this.

## Usage ##
To explicitly use a generator in your property, use the prefix `*` operator (i.e. dereference). This overload returns a value of `T` that was either generated from the given generator or found by shrinking a generated value. For example, to use the `inRange` generator to generate a value in the range `[0, 10)`:

```C++
const auto i = *rc::gen::inRange(0, 10);
```

With this style of using generators, you can also have parameters of a generator depend on value previously generated by other generators. For example:

```C++
const auto max = *rc::gen::arbitrary<int>();
const auto i = *rc::gen::inRange(0, max);
```

In this example, we first generate an arbitrary `int` which becomes the maximum limit for the generation of `i` which will be an `int` between 0 (inclusive) and the first value (exclusive).

Please note that `operator*` is only valid in certain contexts, properties being one of them.

## Arbitrary ##
The most important generator (or family of generators) is `rc::gen::arbitrary<T>()`. As can be deduced from it's name, it returns a generator that will yield a completely arbitrary value of `T`. While it might not always be feasible to do so, the idea is that there should be no possible value of type `T` that cannot be generated by the returned generator.

Out of the box, RapidCheck has support for generating arbitrary values of the following types:

- All primitive built-in types
- `std::array<T, N>`
- `std::vector<T>`
- `std::deque<T>`
- `std::forward_list<T>`
- `std::list<T>`
- `std::set<T>`
- `std::map<K, V>`
- `std::multiset<T>`
- `std::multimap<K, V>`
- `std::unordered_set<T>`
- `std::unordered_map<K, V>`
- `std::unordered_multiset<T>`
- `std::unordered_multimap<K, V>`
- `std::basic_string<T>`
- `std::tuple<Ts...>`
- `std::pair<T1, T2>`

The caveat is, of course, that for template types, RapidCheck must know how to generate the template arguments.

However, it is simple to add support for your own types. To do this, add a specialization of the `Arbitrary` template struct in the namespace `rc`. The specialization should have a static member function named `arbitrary` that should return an appropriate generator. The the following type:

```C++
struct Person {
  std::string firstName;
  std::stirng lastName;
  int age;
};
```

We can add arbitrary support for this type by making the following visible in the file that requests the arbitrary generator:

```C++
template<>
struct Arbitrary<Person> {
  static Gen<Person> arbitrary() {
    return gen::exec([] {
      Person person;
      person.firstName = *gen::arbitrary<std::string>();
      person.lastName = *gen::arbitrary<std::string>();
      person.age = *gen::inRange(0, 100);
      return person;
    });
  }
};
```
